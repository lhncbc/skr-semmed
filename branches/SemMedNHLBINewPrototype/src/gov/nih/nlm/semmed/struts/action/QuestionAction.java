/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package gov.nih.nlm.semmed.struts.action;

import gov.nih.nlm.semmed.model.PubmedArticle;
import gov.nih.nlm.semmed.model.SemMedDocument;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import java.util.Set;
import java.util.Comparator;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.apache.commons.logging.Log;

import gov.nih.nlm.semmed.exception.EssieException;
import gov.nih.nlm.semmed.exception.PubmedException;
import gov.nih.nlm.semmed.exception.SemMedException;
import gov.nih.nlm.semmed.exception.XMLException;
import gov.nih.nlm.semmed.model.APredication;
import gov.nih.nlm.semmed.model.APredicationList;
import gov.nih.nlm.semmed.model.TestPredicationList;
import gov.nih.nlm.semmed.rules.*;
import gov.nih.nlm.semmed.servlet.GraphServlet;
import gov.nih.nlm.semmed.struts.form.QuestionForm;
import gov.nih.nlm.semmed.util.ArticleDataSource;
import gov.nih.nlm.semmed.util.XMLUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts.action.Action;
import org.apache.struts.actions.LookupDispatchAction;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.upload.FormFile;


import org.jdom.Document;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

import com.rapidminer.RapidMiner;
import com.rapidminer.example.Attribute;
import com.rapidminer.example.Example;
import com.rapidminer.example.ExampleSet;
import com.rapidminer.example.table.AttributeFactory;
import com.rapidminer.example.table.DoubleArrayDataRow;
import com.rapidminer.example.table.MemoryExampleTable;
import com.rapidminer.operator.IOContainer;
import com.rapidminer.operator.IOObject;
import com.rapidminer.operator.Model;
import com.rapidminer.operator.ModelApplier;
import com.rapidminer.operator.Operator;
import com.rapidminer.operator.io.ModelLoader;
import com.rapidminer.tools.Ontology;
import com.rapidminer.tools.OperatorService;

/**
 * MyEclipse Struts Creation date: 11-15-2007
 *
 * XDoclet definition:
 *
 * @struts.action path="/Question" name="QuestionForm" input="question.jsp"
 *                scope="request" validate="true"
 */
public class QuestionAction extends LookupDispatchAction {

	protected Map<String,String> getKeyMethodMap() {
	      Map<String,String> map = new HashMap<String,String>();
	      map.put("question.button.findcitationfromdb", "findcitationfromdb");
	      map.put("question.button.uploadincludeexclude", "uploadIncludeExclude");
	      return map;
	  }

	@Override
	public ActionForward unspecified(ActionMapping mapping,
            ActionForm form,
            javax.servlet.http.HttpServletRequest request,
            javax.servlet.http.HttpServletResponse response)
	throws PubmedException, EssieException, SemMedException, Exception {
		if ("findcitationfromdb".equals(request.getParameter("method")))
			return findcitationfromdb(mapping,form,request,response);
		if ("uploadincludeexclude".equals(request.getParameter("method")))
			return uploadIncludeExclude(mapping,form,request,response);
		else
			return super.unspecified(mapping, form, request, response);

	}

	private static Log log = LogFactory.getLog(QuestionAction.class);
	private static HashMap<String, Double> ifhashmap = null; // Hashmap for ImpactFactor
	private static HashMap<String, String> issnhashmap = null; // Hashmap for ISSN/ESSN map


	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward findcitationfromdb(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		QuestionForm QuestionForm = (QuestionForm) form;
		HttpSession session = request.getSession();
		// log.debug("In findcitationfromdb()");

		int page = 0;
		log.debug("request.getParameter(p) '" + request.getParameter("p") + "'");
		log.debug("request.getParameter(display) '" + request.getParameter("display") + "'");
		if (request.getParameter("p") == null) {
			List<APredication> relevantPredications = new ArrayList<APredication>();
			List<Integer> relevantCitations = new ArrayList<Integer>();
			List<APredication> nonRelevantPredications = new ArrayList<APredication>();
			List<Integer> nonRelevantCitations = new ArrayList<Integer>();

			Filter.filterNonRelevants((List<APredication>) session
					.getAttribute("predications"), (Predicate)session.getAttribute("rules"),
					relevantPredications, relevantCitations,
					nonRelevantPredications, nonRelevantCitations);

			nonRelevantCitations.clear();
			for (int i : (int[]) session.getAttribute("citationIDsMedline")) {
				if(i > 0)
				nonRelevantCitations.add(i);
			}
			// nonRelevantCitations.addAll(Arrays.asList());
			nonRelevantCitations.removeAll(relevantCitations);
			Collections.sort(nonRelevantCitations);
			session.setAttribute("relevantQuestionrCitations",
					relevantCitations);
			session.setAttribute("relevantQuestionrPredications",
					relevantPredications);
			session.setAttribute("relevantQuestionnrCitations",
					nonRelevantCitations);
			session.setAttribute("relevantQuestionnrPredications",
					nonRelevantPredications);
			session.setAttribute("summaryPredications", session
					.getAttribute("predications"));
			session.setAttribute("selectedQuestion", QuestionForm
					.getQuestionNumber());
			session.removeAttribute("key");
			sortrcitationqe(request, response);
			sortnrcitationqe(request, response);
		} else {

			try {
				page = Integer.parseInt(request.getParameter("p"));
			} catch (Exception e) {
				page = 0;
			}
		}

		if (request.getParameter("display") == null) {
			showAll(session);
			// rPredications
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			// session.setAttribute("currentQuestionDisplay", "rPredications");
			session.setAttribute("currentQuestionDisplay", "rCitations");

			// rCitations
			List<Integer> citations = (List<Integer>) session.getAttribute("relevantQuestionrCitations");
			List<PubmedArticle> allrCits  = (List<PubmedArticle>) session.getAttribute("allrCitations"); // Save all citations since we already got them all
			log.debug("Size of allrCitations : " + allrCits.size());
			log.debug("Size of citations : " + citations.size());
			List<PubmedArticle> displayedrCits = new ArrayList<PubmedArticle>(20);
			session.removeAttribute("displayedrCitations");

			try {
				for(int k = 0; k < Math.min(allrCits.size(), 20); k++) {
					displayedrCits.add(k,allrCits.get(k));
				}
				session.setAttribute("displayedrCitations", displayedrCits);
			} catch (Exception e) {
				e.printStackTrace();
			}
			session.setAttribute("pageNumberrCitations", page);
			// nrPredications

			predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			PIDs = new int[Math.min(20, predications.size() - page * 20)];
			SIDs = new int[PIDs.length];
			sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);

			// nrCitations
			List<PubmedArticle> allnrCits = (List<PubmedArticle>) session.getAttribute("allnrCitations");
			citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
			List<PubmedArticle> displayednrCits = new ArrayList<PubmedArticle>(20);
			for(int k = 0; k < Math.min(allnrCits.size(), 20); k++) {
				displayednrCits.add(k,allnrCits.get(k));
			}
			session.removeAttribute("displayednrCitations");
			session.setAttribute("displayednrCitations", displayednrCits);

			session.setAttribute("pageNumbernrCitations", page);
		} else if (request.getParameter("display").equals("rPredications")) {

			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			session.setAttribute("currentQuestionDisplay", "rPredications");
		} else if (request.getParameter("display").equals("rCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionrCitations");
				log.debug("Size of relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displayedrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displayedrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayedrCitations", displayedrCitations);
			}

			session.setAttribute("pageNumberrCitations", page);
			session.setAttribute("currentQuestionDisplay", "rCitations");
		} else if (request.getParameter("display").equals("nrPredications")) {
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);
			session.setAttribute("currentQuestionDisplay", "nrPredications");
		} else if (request.getParameter("display").equals("nrCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
				log.debug("Size of non relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
				e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displaednrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allnrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displaednrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayednrCitations", displaednrCitations);
			}

			session.setAttribute("pageNumbernrCitations", page);
			session.setAttribute("currentQuestionDisplay", "nrCitations");
		}
		session.removeAttribute("predsource");
		session.setAttribute("predsource", 2);
		return mapping.findForward("success");
	}



	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	private void sortrcitationqe(HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
			// Implement the quality evidence originally proposed by Halil
			// Nov 06 2008
		// HashMap<String, Double> ifhashmap = null; // Hashmap for ImpactFactor
		// HashMap<String, String> issnhashmap = null; // Hashmap for ISSN/ESSN map
		if(ifhashmap == null) {
			ifhashmap = (HashMap) request.getSession().getServletContext().getAttribute("ifhashmap");
		}
		if(issnhashmap == null) {
			issnhashmap = (HashMap) request.getSession().getServletContext().getAttribute("issnhashmap");
		}

		List attributes = (List) request.getSession().getServletContext().getAttribute("rapidMinerAttributes");
			IOContainer container = (IOContainer) request.getSession().getServletContext().getAttribute("rapidMinerContainer");
			MemoryExampleTable table = new MemoryExampleTable(attributes);
			try {

				HttpSession session = request.getSession();
				List<Integer> rcitations = (List<Integer>) session
				.getAttribute("relevantQuestionrCitations");
				// Get all the Metadatas for the relevant citations
				ArticleDataSource ds = ArticleDataSource
				.getInstance(ArticleDataSource.SourceType.MEDLINE);
				List<PubmedArticle> allrCits = (List<PubmedArticle>) ds.fetch(session,rcitations);
				// log.debug("size of nrcitations from  relevantQuestionrCitations: " + rcitations.size());
				// log.debug("size of allrCits after fetching from PubMed : " + allrCits.size());

				for (int i=0; i < allrCits.size(); i++) {
					Set metadata = (HashSet)(allrCits.get(i)).getMetadata();
					// log.debug("PMID: " + allrCits.get(i).getId());
					// log.debug("Mesh Heading:" + metadata.toString());
					double[] data = new double[attributes.size()];
					for ( int a=0; a<attributes.size(); a++) {
						String name = ((Attribute)attributes.get(a)).getName();
						if (metadata.contains(name)) {
							data[a] = 1.0;
						} else { data[a] = 0.0; }
					}
					table.addDataRow(new DoubleArrayDataRow(data));
				}
				ExampleSet exampleSet = table.createExampleSet();
				// apply the model
				Operator modelApp =  OperatorService .createOperator(ModelApplier.class );
				container = container.append(new IOObject[] {exampleSet});
				container = modelApp.apply(container);

				// print results, iterate through input docs and get the predictions
				ExampleSet resultSet = container.get(ExampleSet.class);
				Iterator eiter = resultSet.iterator();
				Iterator citer = allrCits.iterator();
				while (eiter.hasNext() && citer.hasNext()) {
					Example e = (Example)eiter.next();
					PubmedArticle p = (PubmedArticle) citer.next();
					p.setQualityEvidence(e.getPredictedLabel());
					String issn1 = p.getIssn();
					if(ifhashmap.containsKey(issn1))
						p.setImpactFactor((double)ifhashmap.get(issn1));
					else {
						if(issnhashmap.containsKey(issn1) && ifhashmap.containsKey(issnhashmap.get(issn1)))
							p.setImpactFactor(ifhashmap.get(issnhashmap.get(issn1)));
					}
					// predicted label=1.0 (POSITIVE) 0.0 (NEGATIVE), confidence denote probabilities.
					// log.debug("PMID: " + p.getId() + ", Prediction:" + e.getPredictedLabel() + " " + e.getConfidence("POS") + " " + e.getConfidence("NEG"));
				}
				Collections.sort(allrCits, new citComparatorqe());
				// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
				List<Integer> sortedrCitations = new ArrayList<Integer>(allrCits.size());
				for(int j = 0; j < allrCits.size(); j++) {
					sortedrCitations.add(j,new Integer(allrCits.get(j).getId()));
				}
				session
				.removeAttribute("relevantQuestionrCitations");
				session
				.setAttribute("relevantQuestionrCitations", sortedrCitations);
				List<PubmedArticle> displayedrCits = new ArrayList<PubmedArticle>(20);
				for(int k = 0; k < Math.min(allrCits.size(), 20); k++) {
					displayedrCits.add(k,allrCits.get(k));
				}
				session.removeAttribute("displayedrCitations");
				session.setAttribute("displayedrCitations", displayedrCits);
				session.setAttribute("allrCitations", allrCits); // Save all citations since we already got them all
				session.removeAttribute("pageNumberrCitations");
				session.setAttribute("pageNumberrCitations", 0);
				session.setAttribute("rankingsource", 2);
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	private void sortnrcitationqe(HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
			// Implement the quality evidence originally proposed by Halil
			// Nov 06 2008
		// HashMap<String, Double> ifhashmap = null; // Hashmap for ImpactFactor
		// HashMap<String, String> issnhashmap = null; // Hashmap for ISSN/ESSN map
		if(ifhashmap == null) {
			ifhashmap = (HashMap) request.getSession().getServletContext().getAttribute("ifhashmap");
		}
		if(issnhashmap == null) {
			issnhashmap = (HashMap) request.getSession().getServletContext().getAttribute("issnhashmap");
		}
		List attributes = (List) request.getSession().getServletContext().getAttribute("rapidMinerAttributes");
			IOContainer container = (IOContainer) request.getSession().getServletContext().getAttribute("rapidMinerContainer");
			MemoryExampleTable table = new MemoryExampleTable(attributes);
			try {

				HttpSession session = request.getSession();
				List<Integer> nrcitations = (List<Integer>) session
				.getAttribute("relevantQuestionnrCitations");
				// Get all the Metadatas for the relevant citations
				ArticleDataSource ds = ArticleDataSource
				.getInstance(ArticleDataSource.SourceType.MEDLINE);
				List<PubmedArticle> allnrCits = (List<PubmedArticle>) ds.fetch(session,nrcitations);
				// log.debug("size of nrcitations from  relevantQuestionnrCitations: " + nrcitations.size());
				// log.debug("------------------------------");
				// for(int i = 0;  i < nrcitations.size(); i++)
				//	log.debug("\t" + nrcitations.get(i));
				// log.debug("size of allnrCits after fetching from PubMed : " + allnrCits.size());
				// log.debug("------------------------------");
				for (int i=0; i < allnrCits.size(); i++) {
					Set metadata = (HashSet)(allnrCits.get(i)).getMetadata();
					// log.debug("\t" + allnrCits.get(i).getId());
					// log.debug("Mesh Heading:" + metadata.toString());
					double[] data = new double[attributes.size()];
					for ( int a=0; a<attributes.size(); a++) {
						String name = ((Attribute)attributes.get(a)).getName();
						if (metadata.contains(name)) {
							data[a] = 1.0;
						} else { data[a] = 0.0; }
					}
					table.addDataRow(new DoubleArrayDataRow(data));
				}
				ExampleSet exampleSet = table.createExampleSet();
				// apply the model
				Operator modelApp =  OperatorService .createOperator(ModelApplier.class );
				container = container.append(new IOObject[] {exampleSet});
				container = modelApp.apply(container);

				// print results, iterate through input docs and get the predictions
				ExampleSet resultSet = container.get(ExampleSet.class);
				Iterator eiter = resultSet.iterator();
				Iterator citer = allnrCits.iterator();
				while (eiter.hasNext() && citer.hasNext()) {
					Example e = (Example)eiter.next();
					PubmedArticle p = (PubmedArticle) citer.next();
					p.setQualityEvidence(e.getPredictedLabel());
					String issn1 = p.getIssn();
					if(ifhashmap.containsKey(issn1))
						p.setImpactFactor((double)ifhashmap.get(issn1));
					else {
						if(issnhashmap.containsKey(issn1) && ifhashmap.containsKey(issnhashmap.get(issn1)))
							p.setImpactFactor(ifhashmap.get(issnhashmap.get(issn1)));
					}
					// predicted label=1.0 (POSITIVE) 0.0 (NEGATIVE), confidence denote probabilities.
					// log.debug("PMID: " + p.getId() + ", Prediction:" + e.getPredictedLabel() + " " + e.getConfidence("POS") + " " + e.getConfidence("NEG"));
				}
				Collections.sort(allnrCits, new citComparatorqe());
				// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
				List<Integer> sortednrCitations = new ArrayList<Integer>(allnrCits.size());
				for(int j = 0; j < allnrCits.size(); j++) {
					sortednrCitations.add(j,new Integer(allnrCits.get(j).getId()));
				}
				session
				.removeAttribute("relevantQuestionnrCitations");
				session
				.setAttribute("relevantQuestionnrCitations", sortednrCitations);
				session
				.setAttribute("orgRelevantQuestionnrCitations", nrcitations);
				List<PubmedArticle> displayednrCits = new ArrayList<PubmedArticle>(20);
				for(int k = 0; k < Math.min(allnrCits.size(), 20); k++) {
					displayednrCits.add(k,allnrCits.get(k));
				}
				session.removeAttribute("displayednrCitations");
				session.setAttribute("displayednrCitations", displayednrCits);
				session.setAttribute("allnrCitations", allnrCits); // Save all citations since we got them all
				session.removeAttribute("pageNumbernrCitations");
				session.setAttribute("pageNumbernrCitations", 0);
				session.setAttribute("rankingsource", 2);
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
	}

	// @SuppressWarnings("unchecked")
	private void showAll(HttpSession session) throws SemMedException {
		int page = 0;
		List<APredication> predications = (List<APredication>) session
				.getAttribute("summaryPredications");

		int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
		int[] SIDs = new int[PIDs.length];
		ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

		for (int i = 0; i < PIDs.length; i++) {
			PIDs[i] = predications.get(i + page * 20).PID;
			SIDs[i] = predications.get(i + page * 20).SID;
			sources[i] = predications.get(i + page * 20).source;
		}

		try {
			session.setAttribute("displayedSummaryPredications", new APredicationList(
					PIDs, SIDs, sources));
		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		session.setAttribute("pageNumberPredications", page);
	}

	public class citComparatorif implements Comparator {
		public int compare(Object o1, Object o2) {
			PubmedArticle p1 = (PubmedArticle) o1;
			PubmedArticle p2 = (PubmedArticle) o2;
			double if1=0;
			double if2=0;
			if(p1.ifExist == false) {
				String issn1 = p1.getIssn();
				if(ifhashmap.containsKey(issn1))
					if1 = (double)ifhashmap.get(issn1);
				else {
					if(issnhashmap.containsKey(issn1) && ifhashmap.containsKey(issnhashmap.get(issn1)))
						if1 = ifhashmap.get(issnhashmap.get(issn1));
					else if1 = 0.0;
				}
				p1.ifExist = true;
				p1.setImpactFactor(if1);
			} else
				if1 = p1.getImpactFactor();
			if(p2.ifExist == false) {
				String issn2 = p2.getIssn();
				if(ifhashmap.containsKey(issn2))
					if2 = (double)ifhashmap.get(issn2);
				else {
					if(issnhashmap.containsKey(issn2) && ifhashmap.containsKey(issnhashmap.get(issn2)))
						if2 = ifhashmap.get(issnhashmap.get(issn2));
					else if2 = 0.0;
				}
				p2.ifExist = true;
				p2.setImpactFactor(if2);
			} else
				if2 = p2.getImpactFactor();
			// log.debug("if1 = " + if1 + ", if2 = " + if2);
			if(if2 - if1 > 0 ) return 1;
			else if(if2 - if1 < 0) return -1;
			else return 0;
		}
	}

	public class citComparatorqe implements Comparator {
		public int compare(Object o1, Object o2) {
			PubmedArticle p1 = (PubmedArticle) o1;
			PubmedArticle p2 = (PubmedArticle) o2;
			return new Double(p2.getQualityEvidence() - p1.getQualityEvidence()).intValue();
		}
	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward uploadIncludeExclude(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		QuestionForm questionForm = (QuestionForm) form;
		HttpSession session = request.getSession();
		FormFile includefile = questionForm.getUploadIncludeFile();
		log.debug("Include File : " + includefile.getFileName());
		FormFile excludefile = questionForm.getUploadExcludeFile();
		log.debug("Exclude File : " + excludefile.getFileName());
		int includeLineNum = 0;
		int excludeLineNum = 0;
		int[] idsInclude = new int[10000];
		int[] idsExclude = new int[10000];
		try {
			// PrintWriter out
			//   = new PrintWriter(new BufferedWriter(new FileWriter("C:\\Projects\\SemMedDebug\\PMIDListEcho.out")));
			InputStream isInclude   = includefile.getInputStream();
			BufferedReader brInclude = new BufferedReader(new InputStreamReader(isInclude));

			String aLineInclude = null;
			while((aLineInclude = brInclude.readLine()) != null) {
				idsInclude[includeLineNum] = Integer.parseInt(aLineInclude.trim());
				includeLineNum++;
				// out.println(Integer.parseInt(aLine.trim()));
				// System.out.println(Integer.parseInt(aLine.trim()));
			}

			InputStream isExclude   = excludefile.getInputStream();
			BufferedReader brExclude = new BufferedReader(new InputStreamReader(isExclude));

			String aLineExclude = null;
			while((aLineExclude = brExclude.readLine()) != null) {
				idsExclude[excludeLineNum] = Integer.parseInt(aLineExclude.trim());
				excludeLineNum++;
				// out.println(Integer.parseInt(aLine.trim()));
				// System.out.println(Integer.parseInt(aLine.trim()));
			}
			brInclude.close();
			isInclude.close();
			brExclude.close();
			isExclude.close();
		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}

		int page = 0;
		if (request.getParameter("p") == null) {
			// log.debug("request.getParameter(\"p\") is null");
			List<Integer> relevantCitations = new ArrayList<Integer>(includeLineNum);
			List<Integer> nonRelevantCitations = new ArrayList<Integer>(excludeLineNum);

			int[] idsI = new int[includeLineNum];
			int[] idsE = new int[excludeLineNum];
			for (int i = 0; i < includeLineNum; i++) {
				idsI[i] = idsInclude[i];
				relevantCitations.add(new Integer(idsInclude[i]));
			}
			Collections.sort(relevantCitations);
			for (int i = 0; i < excludeLineNum; i++) {
				idsE[i] = idsExclude[i];
				nonRelevantCitations.add(new Integer(idsExclude[i]));
			}
			ArticleDataSource.SourceType type = ArticleDataSource.SourceType.MEDLINE;
			List<APredication> relevantPredications = null;
			List<APredication> nonRelevantPredications = null;
			try {
			relevantPredications = new TestPredicationList(idsI,type);
			nonRelevantPredications = new TestPredicationList(idsE,type);
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			Collections.sort(nonRelevantCitations);
			List<APredication> allPredications = new ArrayList<APredication>(relevantPredications);
			allPredications.addAll(nonRelevantPredications);

			session.setAttribute("relevantQuestionrCitations",
					relevantCitations);
			session.setAttribute("relevantQuestionrPredications",
					relevantPredications);
			session.setAttribute("relevantQuestionnrCitations",
					nonRelevantCitations);
			session.setAttribute("relevantQuestionnrPredications",
					nonRelevantPredications);
			session.setAttribute("summaryPredications",
					allPredications);
			session.setAttribute("selectedQuestion", questionForm
					.getQuestionNumber());
			session.removeAttribute("key");
			sortrcitationqe(request, response);
			sortnrcitationqe(request, response);
		} else {

			try {
				page = Integer.parseInt(request.getParameter("p"));
			} catch (Exception e) {
				page = 0;
			}
		}

		if (request.getParameter("display") == null) {
			showAll(session);
			// rPredications
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			// log.debug("Size of relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			// session.setAttribute("currentQuestionDisplay", "rPredications");
			session.setAttribute("currentQuestionDisplay", "rCitations");

			// rCitations
			List<Integer> citations = (List<Integer>) session.getAttribute("relevantQuestionrCitations");
			List<PubmedArticle> allrCits  = (List<PubmedArticle>) session.getAttribute("allrCitations"); // Save all citations since we already got them all
			// log.debug("Size of allrCitations : " + allrCits.size());
			// log.debug("Size of citations : " + citations.size());
			List<PubmedArticle> displayedrCits = new ArrayList<PubmedArticle>(20);
			session.removeAttribute("displayedrCitations");

			try {
				for(int k = 0; k < Math.min(allrCits.size(), 20); k++) {
					displayedrCits.add(k,allrCits.get(k));
				}
				session.setAttribute("displayedrCitations", displayedrCits);
			} catch (Exception e) {
				e.printStackTrace();
			}
			session.setAttribute("pageNumberrCitations", page);
			// nrPredications

			predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non-relevant predications : " + predications.size());
			PIDs = new int[Math.min(20, predications.size() - page * 20)];
			SIDs = new int[PIDs.length];
			sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);

			// nrCitations
			List<PubmedArticle> allnrCits = (List<PubmedArticle>) session.getAttribute("allnrCitations");
			citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
			log.debug("size of allnrCits : " + allnrCits.size());
			log.debug("size of relevantQuestionnrCitations : " + citations.size());
			List<PubmedArticle> displayednrCits = new ArrayList<PubmedArticle>(20);
			for(int k = 0; k < Math.min(allnrCits.size(), 20); k++) {
				displayednrCits.add(k,allnrCits.get(k));
			}
			session.removeAttribute("displayednrCitations");
			session.setAttribute("displayednrCitations", displayednrCits);

			session.setAttribute("pageNumbernrCitations", page);
		} else if (request.getParameter("display").equals("rPredications")) {

			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			session.setAttribute("currentQuestionDisplay", "rPredications");
		} else if (request.getParameter("display").equals("rCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionrCitations");
				log.debug("Size of relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displayedrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displayedrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayedrCitations", displayedrCitations);
			}

			session.setAttribute("pageNumberrCitations", page);
			session.setAttribute("currentQuestionDisplay", "rCitations");
		} else if (request.getParameter("display").equals("nrPredications")) {
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);
			session.setAttribute("currentQuestionDisplay", "nrPredications");
		} else if (request.getParameter("display").equals("nrCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetchedrequest.getParameter("p")
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
				e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displaednrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allnrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displaednrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayednrCitations", displaednrCitations);
			}

			session.setAttribute("pageNumbernrCitations", page);
			session.setAttribute("currentQuestionDisplay", "nrCitations");
		}
		session.removeAttribute("predsource");
		session.setAttribute("predsource", 2);
		return mapping.findForward("success");

	}

}
