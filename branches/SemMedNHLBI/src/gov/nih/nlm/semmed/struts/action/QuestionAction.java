/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package gov.nih.nlm.semmed.struts.action;

import gov.nih.nlm.semmed.model.PubmedArticle;
import gov.nih.nlm.semmed.model.SemMedDocument;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import java.util.Set;
import java.util.Comparator;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;

import org.apache.commons.logging.Log;

import gov.nih.nlm.semmed.exception.EssieException;
import gov.nih.nlm.semmed.exception.PubmedException;
import gov.nih.nlm.semmed.exception.SemMedException;
import gov.nih.nlm.semmed.exception.XMLException;
import gov.nih.nlm.semmed.model.APredication;
import gov.nih.nlm.semmed.model.APredicationList;
import gov.nih.nlm.semmed.model.TestPredicationList;
import gov.nih.nlm.semmed.rules.*;
import gov.nih.nlm.semmed.servlet.GraphServlet;
import gov.nih.nlm.semmed.struts.form.QuestionForm;
import gov.nih.nlm.semmed.util.ArticleDataSource;
import gov.nih.nlm.semmed.util.XMLUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.struts.action.Action;
import org.apache.struts.actions.LookupDispatchAction;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;


import org.jdom.Document;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

import com.rapidminer.RapidMiner;
import com.rapidminer.example.Attribute;
import com.rapidminer.example.Example;
import com.rapidminer.example.ExampleSet;
import com.rapidminer.example.table.AttributeFactory;
import com.rapidminer.example.table.DoubleArrayDataRow;
import com.rapidminer.example.table.MemoryExampleTable;
import com.rapidminer.operator.IOContainer;
import com.rapidminer.operator.IOObject;
import com.rapidminer.operator.Model;
import com.rapidminer.operator.ModelApplier;
import com.rapidminer.operator.Operator;
import com.rapidminer.operator.io.ModelLoader;
import com.rapidminer.tools.Ontology;
import com.rapidminer.tools.OperatorService;

/**
 * MyEclipse Struts Creation date: 11-15-2007
 *
 * XDoclet definition:
 *
 * @struts.action path="/Question" name="QuestionForm" input="question.jsp"
 *                scope="request" validate="true"
 */
public class QuestionAction extends LookupDispatchAction {

	protected Map<String,String> getKeyMethodMap() {
	      Map<String,String> map = new HashMap<String,String>();
	      map.put("question.button.findcitation", "findcitation");
	      map.put("question.button.findcitationfromdb", "findcitationfromdb");
	      map.put("question.button.sortrcitationif", "sortrcitationif");
	      map.put("question.button.sortnrcitationif", "sortnrcitationif");
	      map.put("question.button.returnorgrcitation", "returnorgrcitation");
	      map.put("question.button.returnorgnrcitation", "returnorgnrcitation");
	      map.put("question.button.sortrcitationqe", "sortrcitationqe");
	      map.put("question.button.sortnrcitationqe", "sortnrcitationqe");
	      return map;
	  }

	@Override
	public ActionForward unspecified(ActionMapping mapping,
            ActionForm form,
            javax.servlet.http.HttpServletRequest request,
            javax.servlet.http.HttpServletResponse response)
	throws PubmedException, EssieException, SemMedException, Exception {
		if ("findcitation".equals(request.getParameter("method")))
				return findcitation(mapping,form,request,response);
		else if ("findcitationfromdb".equals(request.getParameter("method")))
			return findcitationfromdb(mapping,form,request,response);
		else
			return super.unspecified(mapping, form, request, response);

	}

	private static Log log = LogFactory.getLog(QuestionAction.class);
	private static HashMap<String, Double> ifhashmap = null; // Hashmap for ImpactFactor
	private static HashMap<String, String> issnhashmap = null; // Hashmap for ISSN/ESSN map

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward findcitation(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		QuestionForm QuestionForm = (QuestionForm) form;
		HttpSession session = request.getSession();

		int page = 0;

		if (request.getParameter("p") == null) {

			List<APredication> relevantPredications = new ArrayList<APredication>();
			List<Integer> relevantCitations = new ArrayList<Integer>();
			List<Integer> retrievedCitations = new ArrayList<Integer>();
			List<Integer> relevantCitationsInitial = new ArrayList<Integer>();
			List<APredication> nonRelevantPredications = new ArrayList<APredication>();
			List<Integer> nonRelevantCitations = new ArrayList<Integer>();

			List<APredication> predList = (List<APredication>) session.getAttribute("predications");
			if(predList != null && predList.size() > 0)
				Filter.filterNonRelevants(predList, (Predicate)session.getAttribute("rules"),
					relevantPredications, relevantCitationsInitial,
					nonRelevantPredications, nonRelevantCitations);

			nonRelevantCitations.clear();
			if(session.getAttribute("citationIDsMedline") != null) {
				for (int i : (int[]) session.getAttribute("citationIDsMedline")) {
					relevantCitations.add(i);
					nonRelevantCitations.add(i);
					retrievedCitations.add(i);
				}
			}
			else if(session.getAttribute("citationIDsEssie") != null) {
				for (int i : (int[]) session.getAttribute("citationIDsEssie")) {
					relevantCitations.add(i);
					nonRelevantCitations.add(i);
					retrievedCitations.add(i);
				}
			}

			session.setAttribute("retrievedCitations",
					retrievedCitations);
			// nonRelevantCitations.addAll(Arrays.asList());
			nonRelevantCitations.removeAll(relevantCitationsInitial);
			relevantCitations.removeAll(nonRelevantCitations);
			// Collections.sort(nonRelevantCitations);
			session.setAttribute("relevantQuestionrCitations",
					relevantCitations);
			session.setAttribute("relevantQuestionrPredications",
					relevantPredications);
			session.setAttribute("relevantQuestionnrCitations",
					nonRelevantCitations);
			session.setAttribute("relevantQuestionnrPredications",
					nonRelevantPredications);
			session.setAttribute("summaryPredications", session
					.getAttribute("predications"));
			session.setAttribute("selectedQuestion", QuestionForm
					.getQuestionNumber());
			session.removeAttribute("key");
		} else {

			try {
				page = Integer.parseInt(request.getParameter("p"));
			} catch (Exception e) {
				page = 0;
			}
		}

		if (request.getParameter("display") == null) {
			showAll(session);
			// rPredications
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			// session.setAttribute("currentQuestionDisplay", "rPredications");
			session.setAttribute("currentQuestionDisplay", "rCitations");

			// rCitations
			List<Integer> PMIDs = new ArrayList<Integer>(20);
			List<Integer> citations = (List<Integer>) session.getAttribute("relevantQuestionrCitations");
			log.debug("Size of relevant citations : " + citations.size());
			for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
				PMIDs.add(citations.get(i));

			try {
				// TODO [Alejandro] I actually need different sources for different citations!
				ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE);
				session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
			} catch (Exception e) {
				e.printStackTrace();
			}
			session.setAttribute("pageNumberrCitations", page);

			// nrPredications

			predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non-relevant predications : " + predications.size());
			PIDs = new int[Math.min(20, predications.size() - page * 20)];
			SIDs = new int[PIDs.length];
			sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);

			// nrCitations
			PMIDs = new ArrayList<Integer>(20);
			citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
			log.debug("Size of non-relevant citations : " + citations.size());
			for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
				PMIDs.add(citations.get(i));

			try {
				ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
				session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
			} catch (Exception e) {
				e.printStackTrace();
			}

			session.setAttribute("pageNumbernrCitations", page);
		} else if (request.getParameter("display").equals("rPredications")) {

			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			session.setAttribute("currentQuestionDisplay", "rPredications");
		} else if (request.getParameter("display").equals("rCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionrCitations");
				log.debug("Size of relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displayedrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displayedrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayedrCitations", displayedrCitations);
			}

			session.setAttribute("pageNumberrCitations", page);
			session.setAttribute("currentQuestionDisplay", "rCitations");
		} else if (request.getParameter("display").equals("nrPredications")) {
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);
			session.setAttribute("currentQuestionDisplay", "nrPredications");
		} else if (request.getParameter("display").equals("nrCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
				log.debug("Size of non relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
				e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displaednrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allnrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displaednrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayednrCitations", displaednrCitations);
			}
			session.setAttribute("pageNumbernrCitations", page);
			session.setAttribute("currentQuestionDisplay", "nrCitations");
		}
		session.removeAttribute("predsource");
		session.setAttribute("predsource", 1);
		return mapping.findForward("success");
	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward findcitationfromdb(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		QuestionForm QuestionForm = (QuestionForm) form;
		HttpSession session = request.getSession();

		int page = 0;

		if (request.getParameter("p") == null) {

			List<APredication> relevantPredications = new ArrayList<APredication>();
			List<Integer> relevantCitations = new ArrayList<Integer>();
			List<APredication> nonRelevantPredications = new ArrayList<APredication>();
			List<Integer> nonRelevantCitations = new ArrayList<Integer>();

			Filter.filterNonRelevants((List<APredication>) session
					.getAttribute("predications"), (Predicate)session.getAttribute("rules"),
					relevantPredications, relevantCitations,
					nonRelevantPredications, nonRelevantCitations);

			nonRelevantCitations.clear();
			for (int i : (int[]) session.getAttribute("citationIDsMedline")) {
				if(i > 0)
				nonRelevantCitations.add(i);
			}
			// nonRelevantCitations.addAll(Arrays.asList());
			nonRelevantCitations.removeAll(relevantCitations);
			Collections.sort(nonRelevantCitations);
			session.setAttribute("relevantQuestionrCitations",
					relevantCitations);
			session.setAttribute("relevantQuestionrPredications",
					relevantPredications);
			session.setAttribute("relevantQuestionnrCitations",
					nonRelevantCitations);
			session.setAttribute("relevantQuestionnrPredications",
					nonRelevantPredications);
			session.setAttribute("summaryPredications", session
					.getAttribute("predications"));
			session.setAttribute("selectedQuestion", QuestionForm
					.getQuestionNumber());
			session.removeAttribute("key");
		} else {

			try {
				page = Integer.parseInt(request.getParameter("p"));
			} catch (Exception e) {
				page = 0;
			}
		}

		if (request.getParameter("display") == null) {
			showAll(session);
			// rPredications
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			// session.setAttribute("currentQuestionDisplay", "rPredications");
			session.setAttribute("currentQuestionDisplay", "rCitations");

			// rCitations
			List<Integer> PMIDs = new ArrayList<Integer>(20);
			List<Integer> citations = (List<Integer>) session.getAttribute("relevantQuestionrCitations");
			log.debug("Size of relevant citations : " + citations.size());
			for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
				PMIDs.add(citations.get(i));

			try {
				// TODO [Alejandro] I actually need different sources for different citations!
				ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE);
				session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
			} catch (Exception e) {
				e.printStackTrace();
			}
			session.setAttribute("pageNumberrCitations", page);

			// nrPredications

			predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non-relevant predications : " + predications.size());
			PIDs = new int[Math.min(20, predications.size() - page * 20)];
			SIDs = new int[PIDs.length];
			sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);

			// nrCitations
			PMIDs = new ArrayList<Integer>(20);
			citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
			log.debug("Size of non-relevant citations : " + citations.size());
			for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
				PMIDs.add(citations.get(i));

			try {
				ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
				session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
			} catch (Exception e) {
				e.printStackTrace();
			}

			session.setAttribute("pageNumbernrCitations", page);
		} else if (request.getParameter("display").equals("rPredications")) {

			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayedrPredications",
						new APredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumberrPredications", page);
			session.setAttribute("currentQuestionDisplay", "rPredications");
		} else if (request.getParameter("display").equals("rCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionrCitations");
				log.debug("Size of relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayedrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displayedrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displayedrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayedrCitations", displayedrCitations);
			}

			session.setAttribute("pageNumberrCitations", page);
			session.setAttribute("currentQuestionDisplay", "rCitations");
		} else if (request.getParameter("display").equals("nrPredications")) {
			List<APredication> predications = (List<APredication>) session
					.getAttribute("relevantQuestionnrPredications");
			log.debug("Size of non relevant predications : " + predications.size());
			int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
			int[] SIDs = new int[PIDs.length];
			ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

			for (int i = 0; i < PIDs.length; i++) {
				PIDs[i] = predications.get(i + page * 20).PID;
				SIDs[i] = predications.get(i + page * 20).SID;
				sources[i] = predications.get(i + page * 20).source;
			}

			try {
				session.setAttribute("displayednrPredications",
						new TestPredicationList(PIDs, SIDs, sources));
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
			session.setAttribute("pageNumbernrPredications", page);
			session.setAttribute("currentQuestionDisplay", "nrPredications");
		} else if (request.getParameter("display").equals("nrCitations")) {
			if(session.getAttribute("rankingsource") == null) { // if no ranking strategy is used and citations are not prefetched
				List<Integer> PMIDs = new ArrayList<Integer>(20);
				List<Integer> citations = (List<Integer>) session
					.getAttribute("relevantQuestionnrCitations");
				log.debug("Size of non relevant citations : " + citations.size());
				for (int i = page * 20; i < citations.size() && i < (page + 1) * 20; i++)
					PMIDs.add(citations.get(i));

				try {
					ArticleDataSource ds = ArticleDataSource
						.getInstance(ArticleDataSource.SourceType.MEDLINE); // TODO
					session.setAttribute("displayednrCitations", ds.fetch(session,
						PMIDs));
				} catch (Exception e) {
				e.printStackTrace();
				}
			} else { //if a ranking strategy is used and all the citations are prefetched
				List<PubmedArticle> displaednrCitations = new ArrayList<PubmedArticle>(20);
				List<PubmedArticle> savedAllCits = (List<PubmedArticle>) session
					.getAttribute("allnrCitations");
				for (int i = page * 20; i < savedAllCits.size() && i < (page + 1) * 20; i++)
					displaednrCitations.add(savedAllCits.get(i));
				session.setAttribute("displayednrCitations", displaednrCitations);
			}

			session.setAttribute("pageNumbernrCitations", page);
			session.setAttribute("currentQuestionDisplay", "nrCitations");
		}
		session.removeAttribute("predsource");
		session.setAttribute("predsource", 2);
		return mapping.findForward("success");
	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward sortrcitationif(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		try {
			HttpSession session = request.getSession();
			List<Integer> rcitations = (List<Integer>) session
				.getAttribute("relevantQuestionrCitations");
			if(ifhashmap == null) {
				ifhashmap = (HashMap) request.getSession().getServletContext().getAttribute("ifhashmap");
			}
			if(issnhashmap == null) {
				issnhashmap = (HashMap) request.getSession().getServletContext().getAttribute("issnhashmap");
			}
			ArticleDataSource ds = ArticleDataSource
			.getInstance(ArticleDataSource.SourceType.MEDLINE);
			List<PubmedArticle> allrCits = (List<PubmedArticle>) ds.fetch(session,rcitations);
			Collections.sort(allrCits, new citComparatorif());
			// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
			List<Integer> sortedrCitations = new ArrayList<Integer>(allrCits.size());
			for(int j = 0; j < allrCits.size(); j++) {
				sortedrCitations.add(j,new Integer(allrCits.get(j).getId()));
			}
			session
			.removeAttribute("relevantQuestionrCitations");
			session
			.setAttribute("relevantQuestionrCitations", sortedrCitations);
			session
			.setAttribute("orgRelevantQuestionrCitations", rcitations);
			List<PubmedArticle> displayedrCits = new ArrayList<PubmedArticle>(20);
			for(int k = 0; k < Math.min(allrCits.size(), 20); k++) {
				displayedrCits.add(k,allrCits.get(k));
			}
			session.removeAttribute("displayedrCitations");
			session.setAttribute("displayedrCitations", displayedrCits);
			session.setAttribute("allrCitations", allrCits);
			session.removeAttribute("pageNumberrCitations");
			session.setAttribute("pageNumberrCitations", 0);
			session.setAttribute("rankingsource", 1);

		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		return mapping.findForward("success");

	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward sortnrcitationif(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		try {
			HttpSession session = request.getSession();
			List<Integer> nrcitations = (List<Integer>) session
			.getAttribute("relevantQuestionnrCitations");
			if(ifhashmap == null) {
				ifhashmap = (HashMap) request.getSession().getServletContext().getAttribute("ifhashmap");
			}
			if(issnhashmap == null) {
				issnhashmap = (HashMap) request.getSession().getServletContext().getAttribute("issnhashmap");
			}
			ArticleDataSource ds = ArticleDataSource
			.getInstance(ArticleDataSource.SourceType.MEDLINE);

			List<PubmedArticle> allnrCits = (List<PubmedArticle>) ds.fetch(session,nrcitations);
			Collections.sort(allnrCits, new citComparatorif());
			// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
			List<Integer> sortednrCitations = new ArrayList<Integer>(allnrCits.size());
			for(int j = 0; j < allnrCits.size(); j++) {
				sortednrCitations.add(j,new Integer(allnrCits.get(j).getId()));
			}
			session
			.removeAttribute("relevantQuestionnrCitations");
			session
			.setAttribute("relevantQuestionnrCitations", sortednrCitations);
			session
			.setAttribute("orgRelevantQuestionnrCitations", nrcitations);
			List<PubmedArticle> displayednrCits = new ArrayList<PubmedArticle>(20);
			for(int k = 0; k < Math.min(allnrCits.size(), 20); k++) {
				displayednrCits.add(k,allnrCits.get(k));
			}
			session.removeAttribute("displayednrCitations");
			session.setAttribute("displayednrCitations", displayednrCits);
			session.setAttribute("allnrCitations", allnrCits);
			session.removeAttribute("pageNumbernrCitations");
			session.setAttribute("pageNumbernrCitations", 0);
			session.setAttribute("rankingsource", 1);

		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		return mapping.findForward("success");

	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward returnorgrcitation(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		try {
			HttpSession session = request.getSession();
			List<Integer> rPMIDs = new ArrayList<Integer>(20);
			List<Integer> rcitations = (List<Integer>) session
				.getAttribute("orgRelevantQuestionrCitations");
			ArticleDataSource ds = ArticleDataSource
			.getInstance(ArticleDataSource.SourceType.MEDLINE);
			log.debug("Size of original relevant citations : " + rcitations.size());
			for (int i = 0; i < rcitations.size() && i < 20; i++)
				rPMIDs.add(rcitations.get(i));
			session.removeAttribute("orgRelevantQuestionrCitations");
			session.removeAttribute("displayedrCitations");
			session.removeAttribute("allrCitations");
			session.removeAttribute("rankingsource");
			session.setAttribute("relevantQuestionrCitations", rcitations);
			session.setAttribute("displayedrCitations", ds.fetch(session,
					rPMIDs));
			session.setAttribute("pageNumberrCitations", 0);

		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		return mapping.findForward("success");

	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward returnorgnrcitation(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
		try {
			HttpSession session = request.getSession();
			List<Integer> nrPMIDs = new ArrayList<Integer>(20);
			List<Integer> nrcitations = (List<Integer>) session
				.getAttribute("orgRelevantQuestionnrCitations");
			ArticleDataSource ds = ArticleDataSource
			.getInstance(ArticleDataSource.SourceType.MEDLINE);
			log.debug("Size of original non-relevant citations : " + nrcitations.size());
			for (int i = 0; i < nrcitations.size() && i < 20; i++)
				nrPMIDs.add(nrcitations.get(i));
			session.removeAttribute("orgRelevantQuestionnrCitations");
			session.removeAttribute("displayednrCitations");
			session.removeAttribute("allnrCitations");
			session.removeAttribute("rankingsource");
			session.setAttribute("relevantQuestionnrCitations", nrcitations);
			session.setAttribute("displayednrCitations", ds.fetch(session,
					nrPMIDs));
			session.setAttribute("pageNumbernrCitations", 0);

		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		return mapping.findForward("success");

	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward sortrcitationqe(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
			// Implement the quality evidence originally proposed by Halil
			// Nov 06 2008
			List attributes = (List) request.getSession().getServletContext().getAttribute("rapidMinerAttributes");
			IOContainer container = (IOContainer) request.getSession().getServletContext().getAttribute("rapidMinerContainer");
			MemoryExampleTable table = new MemoryExampleTable(attributes);
			try {

				HttpSession session = request.getSession();
				List<Integer> rcitations = (List<Integer>) session
				.getAttribute("relevantQuestionrCitations");
				// Get all the Metadatas for the relevant citations
				ArticleDataSource ds = ArticleDataSource
				.getInstance(ArticleDataSource.SourceType.MEDLINE);
				List<PubmedArticle> allrCits = (List<PubmedArticle>) ds.fetch(session,rcitations);

				for (int i=0; i < allrCits.size(); i++) {
					Set metadata = (HashSet)(allrCits.get(i)).getMetadata();
					log.debug("PMID: " + allrCits.get(i).getId());
					log.debug("Mesh Heading:" + metadata.toString());
					double[] data = new double[attributes.size()];
					for ( int a=0; a<attributes.size(); a++) {
						String name = ((Attribute)attributes.get(a)).getName();
						if (metadata.contains(name)) {
							data[a] = 1.0;
						} else { data[a] = 0.0; }
					}
					table.addDataRow(new DoubleArrayDataRow(data));
				}
				ExampleSet exampleSet = table.createExampleSet();
				// apply the model
				Operator modelApp =  OperatorService .createOperator(ModelApplier.class );
				container = container.append(new IOObject[] {exampleSet});
				container = modelApp.apply(container);

				// print results, iterate through input docs and get the predictions
				ExampleSet resultSet = container.get(ExampleSet.class);
				Iterator eiter = resultSet.iterator();
				Iterator citer = allrCits.iterator();
				while (eiter.hasNext() && citer.hasNext()) {
					Example e = (Example)eiter.next();
					PubmedArticle p = (PubmedArticle) citer.next();
					p.setQualityEvidence(e.getPredictedLabel());
					// predicted label=1.0 (POSITIVE) 0.0 (NEGATIVE), confidence denote probabilities.
					log.debug("PMID: " + p.getId() + ", Prediction:" + e.getPredictedLabel() + " " + e.getConfidence("POS") + " " + e.getConfidence("NEG"));
				}
				Collections.sort(allrCits, new citComparatorqe());
				// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
				List<Integer> sortedrCitations = new ArrayList<Integer>(allrCits.size());
				for(int j = 0; j < allrCits.size(); j++) {
					sortedrCitations.add(j,new Integer(allrCits.get(j).getId()));
				}
				session
				.removeAttribute("relevantQuestionrCitations");
				session
				.setAttribute("relevantQuestionrCitations", sortedrCitations);
				session
				.setAttribute("orgRelevantQuestionrCitations", rcitations);
				List<PubmedArticle> displayedrCits = new ArrayList<PubmedArticle>(20);
				for(int k = 0; k < Math.min(allrCits.size(), 20); k++) {
					displayedrCits.add(k,allrCits.get(k));
				}
				session.removeAttribute("displayedrCitations");
				session.setAttribute("displayedrCitations", displayedrCits);
				session.setAttribute("allrCitations", allrCits); // Save all citations since we already got them all
				session.removeAttribute("pageNumberrCitations");
				session.setAttribute("pageNumberrCitations", 0);
				session.setAttribute("rankingsource", 2);
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
		return mapping.findForward("success");
	}

	/**
	 * Method execute
	 *
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 * @throws SemMedException
	 */
	// @SuppressWarnings("unchecked")
	public ActionForward sortnrcitationqe(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws SemMedException {
			// Implement the quality evidence originally proposed by Halil
			// Nov 06 2008
			List attributes = (List) request.getSession().getServletContext().getAttribute("rapidMinerAttributes");
			IOContainer container = (IOContainer) request.getSession().getServletContext().getAttribute("rapidMinerContainer");
			MemoryExampleTable table = new MemoryExampleTable(attributes);
			try {

				HttpSession session = request.getSession();
				List<Integer> nrcitations = (List<Integer>) session
				.getAttribute("relevantQuestionnrCitations");
				// Get all the Metadatas for the relevant citations
				ArticleDataSource ds = ArticleDataSource
				.getInstance(ArticleDataSource.SourceType.MEDLINE);
				List<PubmedArticle> allnrCits = (List<PubmedArticle>) ds.fetch(session,nrcitations);

				for (int i=0; i < allnrCits.size(); i++) {
					Set metadata = (HashSet)(allnrCits.get(i)).getMetadata();
					log.debug("PMID: " + allnrCits.get(i).getId());
					log.debug("Mesh Heading:" + metadata.toString());
					double[] data = new double[attributes.size()];
					for ( int a=0; a<attributes.size(); a++) {
						String name = ((Attribute)attributes.get(a)).getName();
						if (metadata.contains(name)) {
							data[a] = 1.0;
						} else { data[a] = 0.0; }
					}
					table.addDataRow(new DoubleArrayDataRow(data));
				}
				ExampleSet exampleSet = table.createExampleSet();
				// apply the model
				Operator modelApp =  OperatorService .createOperator(ModelApplier.class );
				container = container.append(new IOObject[] {exampleSet});
				container = modelApp.apply(container);

				// print results, iterate through input docs and get the predictions
				ExampleSet resultSet = container.get(ExampleSet.class);
				Iterator eiter = resultSet.iterator();
				Iterator citer = allnrCits.iterator();
				while (eiter.hasNext() && citer.hasNext()) {
					Example e = (Example)eiter.next();
					PubmedArticle p = (PubmedArticle) citer.next();
					p.setQualityEvidence(e.getPredictedLabel());
					// predicted label=1.0 (POSITIVE) 0.0 (NEGATIVE), confidence denote probabilities.
					log.debug("PMID: " + p.getId() + ", Prediction:" + e.getPredictedLabel() + " " + e.getConfidence("POS") + " " + e.getConfidence("NEG"));
				}
				Collections.sort(allnrCits, new citComparatorqe());
				// log.debug("Citation sorted  with Impact Factor with the new list size = " + allCits.size());
				List<Integer> sortednrCitations = new ArrayList<Integer>(allnrCits.size());
				for(int j = 0; j < allnrCits.size(); j++) {
					sortednrCitations.add(j,new Integer(allnrCits.get(j).getId()));
				}
				session
				.removeAttribute("relevantQuestionnrCitations");
				session
				.setAttribute("relevantQuestionnrCitations", sortednrCitations);
				session
				.setAttribute("orgRelevantQuestionnrCitations", nrcitations);
				List<PubmedArticle> displayednrCits = new ArrayList<PubmedArticle>(20);
				for(int k = 0; k < Math.min(allnrCits.size(), 20); k++) {
					displayednrCits.add(k,allnrCits.get(k));
				}
				session.removeAttribute("displayednrCitations");
				session.setAttribute("displayednrCitations", displayednrCits);
				session.setAttribute("allnrCitations", allnrCits); // Save all citations since we got them all
				session.removeAttribute("pageNumbernrCitations");
				session.setAttribute("pageNumbernrCitations", 0);
				session.setAttribute("rankingsource", 2);
			} catch (Exception e) {
				e.printStackTrace();
				throw new SemMedException(e);
			}
		return mapping.findForward("success");
	}

	// @SuppressWarnings("unchecked")
	private void showAll(HttpSession session) throws SemMedException {
		int page = 0;
		List<APredication> predications = (List<APredication>) session
				.getAttribute("summaryPredications");

		int[] PIDs = new int[Math.min(20, predications.size() - page * 20)];
		int[] SIDs = new int[PIDs.length];
		ArticleDataSource.SourceType[] sources = new ArticleDataSource.SourceType[PIDs.length];

		for (int i = 0; i < PIDs.length; i++) {
			PIDs[i] = predications.get(i + page * 20).PID;
			SIDs[i] = predications.get(i + page * 20).SID;
			sources[i] = predications.get(i + page * 20).source;
		}

		try {
			session.setAttribute("displayedSummaryPredications", new APredicationList(
					PIDs, SIDs, sources));
		} catch (Exception e) {
			e.printStackTrace();
			throw new SemMedException(e);
		}
		session.setAttribute("pageNumberPredications", page);
	}

	public class citComparatorif implements Comparator {
		public int compare(Object o1, Object o2) {
			PubmedArticle p1 = (PubmedArticle) o1;
			PubmedArticle p2 = (PubmedArticle) o2;
			double if1=0;
			double if2=0;
			if(p1.ifExist == false) {
				String issn1 = p1.getIssn();
				if(ifhashmap.containsKey(issn1))
					if1 = (double)ifhashmap.get(issn1);
				else {
					if(issnhashmap.containsKey(issn1) && ifhashmap.containsKey(issnhashmap.get(issn1)))
						if1 = ifhashmap.get(issnhashmap.get(issn1));
					else if1 = 0.0;
				}
				p1.ifExist = true;
				p1.setImpactFactor(if1);
			} else
				if1 = p1.getImpactFactor();
			if(p2.ifExist == false) {
				String issn2 = p2.getIssn();
				if(ifhashmap.containsKey(issn2))
					if2 = (double)ifhashmap.get(issn2);
				else {
					if(issnhashmap.containsKey(issn2) && ifhashmap.containsKey(issnhashmap.get(issn2)))
						if2 = ifhashmap.get(issnhashmap.get(issn2));
					else if2 = 0.0;
				}
				p2.ifExist = true;
				p2.setImpactFactor(if2);
			} else
				if2 = p2.getImpactFactor();
			// log.debug("if1 = " + if1 + ", if2 = " + if2);
			if(if2 - if1 > 0 ) return 1;
			else if(if2 - if1 < 0) return -1;
			else return 0;
		}
	}

	public class citComparatorqe implements Comparator {
		public int compare(Object o1, Object o2) {
			PubmedArticle p1 = (PubmedArticle) o1;
			PubmedArticle p2 = (PubmedArticle) o2;
			return new Double(p2.getQualityEvidence() - p1.getQualityEvidence()).intValue();
		}
	}
}
